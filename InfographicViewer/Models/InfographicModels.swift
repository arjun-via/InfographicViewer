import Foundation
import SwiftUI

// MARK: - Interactive Infographic Models
// These models decode the hierarchical JSON generated by repo2interactive.py

/// Root structure of the interactive infographic JSON
struct InteractiveInfographic: Codable, Identifiable {
    let version: String
    let schema: String
    let repoUrl: String
    let repoName: String
    let repoSummary: String
    let pipelineOverview: String?
    let generatedAt: String
    let root: InfographicNode
    
    var id: String { repoName }
    
    enum CodingKeys: String, CodingKey {
        case version, schema
        case repoUrl = "repo_url"
        case repoName = "repo_name"
        case repoSummary = "repo_summary"
        case pipelineOverview = "pipeline_overview"
        case generatedAt = "generated_at"
        case root
    }
}

/// Node types in the hierarchy
enum InfographicNodeType: String, Codable {
    case repo
    case phase
    case step
    case file
    case function
    case codeBlock = "code_block"
    
    /// Display name for the node type
    var displayName: String {
        switch self {
        case .repo: return "REPO"
        case .phase: return "PHASE"
        case .step: return "STEP"
        case .file: return "FILE"
        case .function: return "FUNCTION"
        case .codeBlock: return "CODE"
        }
    }
    
    /// Color for the node type
    var color: Color {
        switch self {
        case .repo: return Color(hex: "58A6FF")
        case .phase: return Color(hex: "A371F7")
        case .step: return Color(hex: "3FB950")
        case .file: return Color(hex: "D29922")
        case .function: return Color(hex: "F778BA")
        case .codeBlock: return Color(hex: "F85149")
        }
    }
    
    /// Background color (lighter version)
    var backgroundColor: Color {
        switch self {
        case .repo: return Color(hex: "1A2332")
        case .phase: return Color(hex: "2D1F47")
        case .step: return Color(hex: "1A2E1A")
        case .file: return Color(hex: "2A2510")
        case .function: return Color(hex: "2A1A25")
        case .codeBlock: return Color(hex: "2A1515")
        }
    }
    
    /// SF Symbol icon name
    var iconName: String {
        switch self {
        case .repo: return "folder.fill"
        case .phase: return "rectangle.stack.fill"
        case .step: return "arrow.right.circle.fill"
        case .file: return "doc.text.fill"
        case .function: return "function"
        case .codeBlock: return "chevron.left.forwardslash.chevron.right"
        }
    }
}

/// A node in the infographic hierarchy
struct InfographicNode: Codable, Identifiable {
    let id: String
    let type: InfographicNodeType
    let label: String
    let description: String?
    let children: [InfographicNode]
    let visualHint: VisualHint?
    let phaseMetadata: PhaseMetadata?
    let stepMetadata: StepMetadata?
    let fileMetadata: FileMetadata?
    let functionMetadata: FunctionMetadata?
    let codeMetadata: CodeMetadata?
    let connections: [Connection]?
    
    enum CodingKeys: String, CodingKey {
        case id, type, label, description, children
        case visualHint = "visual_hint"
        case phaseMetadata = "phase_metadata"
        case stepMetadata = "step_metadata"
        case fileMetadata = "file_metadata"
        case functionMetadata = "function_metadata"
        case codeMetadata = "code_metadata"
        case connections
    }
    
    /// Check if this node has children
    var hasChildren: Bool {
        !children.isEmpty
    }
    
    /// Check if this is a code leaf node
    var isCodeBlock: Bool {
        type == .codeBlock
    }
    
    /// Get the appropriate icon name
    var iconName: String {
        visualHint?.icon ?? type.iconName
    }
    
    /// Get the node color
    var nodeColor: Color {
        if let hexColor = visualHint?.color {
            return Color(hex: hexColor.replacingOccurrences(of: "#", with: ""))
        }
        return type.color
    }
}

/// Visual styling hints
struct VisualHint: Codable {
    let icon: String?
    let color: String?
    let badge: String?
}

/// Metadata for phase nodes
struct PhaseMetadata: Codable {
    let phaseId: String?
    let phasePurpose: String?
    
    enum CodingKeys: String, CodingKey {
        case phaseId = "phase_id"
        case phasePurpose = "phase_purpose"
    }
}

/// Metadata for step nodes
struct StepMetadata: Codable {
    let stepId: String?
    let sourceNodes: [String]?
    let targetNodes: [String]?
    let processScript: String?
    let notes: String?
    
    enum CodingKeys: String, CodingKey {
        case stepId = "step_id"
        case sourceNodes = "source_nodes"
        case targetNodes = "target_nodes"
        case processScript = "process_script"
        case notes
    }
}

/// Metadata for file nodes
struct FileMetadata: Codable {
    let filePath: String?
    let language: String?
    let githubUrl: String?
    let lineCount: Int?
    
    enum CodingKeys: String, CodingKey {
        case filePath = "file_path"
        case language
        case githubUrl = "github_url"
        case lineCount = "line_count"
    }
}

/// Metadata for function nodes
struct FunctionMetadata: Codable {
    let functionName: String?
    let filePath: String?
    let lineStart: Int?
    let lineEnd: Int?
    let githubUrl: String?
    let signature: String?
    let docstring: String?
    
    enum CodingKeys: String, CodingKey {
        case functionName = "function_name"
        case filePath = "file_path"
        case lineStart = "line_start"
        case lineEnd = "line_end"
        case githubUrl = "github_url"
        case signature, docstring
    }
}

/// Metadata for code block nodes
struct CodeMetadata: Codable {
    let code: String?
    let language: String?
    let filePath: String?
    let lineStart: Int?
    let lineEnd: Int?
    let githubUrl: String?
    let annotations: [CodeAnnotation]?
    
    enum CodingKeys: String, CodingKey {
        case code, language
        case filePath = "file_path"
        case lineStart = "line_start"
        case lineEnd = "line_end"
        case githubUrl = "github_url"
        case annotations
    }
}

/// Code annotation for explaining specific lines
struct CodeAnnotation: Codable, Identifiable {
    let line: Int
    let comment: String
    
    var id: Int { line }
}

/// Data flow connection between nodes
struct Connection: Codable, Identifiable {
    let targetId: String
    let label: String?
    let direction: String?
    
    var id: String { targetId }
    
    enum CodingKeys: String, CodingKey {
        case targetId = "target_id"
        case label, direction
    }
    
    var isOutgoing: Bool {
        direction == "outgoing"
    }
}

// MARK: - Sample Data

extension InteractiveInfographic {
    /// Load infographic from a JSON file in the bundle
    static func load(from filename: String) -> InteractiveInfographic? {
        guard let url = Bundle.main.url(forResource: filename, withExtension: "json"),
              let data = try? Data(contentsOf: url) else {
            return nil
        }
        
        let decoder = JSONDecoder()
        return try? decoder.decode(InteractiveInfographic.self, from: data)
    }
    
    /// Load infographic from JSON data
    static func load(from data: Data) -> InteractiveInfographic? {
        let decoder = JSONDecoder()
        return try? decoder.decode(InteractiveInfographic.self, from: data)
    }
    
    /// Load infographic from a URL
    static func load(from url: URL) async -> InteractiveInfographic? {
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            return load(from: data)
        } catch {
            print("Failed to load infographic: \(error)")
            return nil
        }
    }
}
